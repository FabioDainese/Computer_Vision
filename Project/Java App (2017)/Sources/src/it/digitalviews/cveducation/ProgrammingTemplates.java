package it.digitalviews.cveducation;

public class ProgrammingTemplates {

public static final String[] ChromaKeyStub = new String[] {

"/**",
" * La procedura chromaKey deve popolare una maschera di valori booleani in accordo con la compatibilità",
" * dei pixel dell'immagine con un dato punto del piano u-v",
" *",
" * parametro u : la coordinata u del punto di riferimento",
" * parametro v : la coordinata v del punto di riferimento",
" * parametro radius : la massima distanza di un punto immagine dal riferimento per essere considerato valido",
" * parametro uData : matrice con i valori u dei pixel dell'immagine",
" * parametro vData : matrice con i valori v dei pixel dell'immagine",
" * parametro mask : matrice di booleani da riempire ad opera della procedura",
" */",
"public void chromaKey( double u, double v, double radius, double[][] uData, double[][] vData,",
"                       boolean[][] mask ){",
"",
"       // Inserire testo qui",
"",
"}",
""

};

public static final String[] ChromaKeyReference = new String[] {

"/**",
" * La procedura chromaKey deve popolare una maschera di valori booleani in accordo con la compatibilità",
" * dei pixel dell'immagine con un dato punto del piano u-v",
" *",
" * parametro u : la coordinata u del punto di riferimento",
" * parametro v : la coordinata v del punto di riferimento",
" * parametro radius : la massima distanza di un punto immagine dal riferimento per essere considerato valido",
" * parametro uData : matrice con i valori u dei pixel dell'immagine",
" * parametro vData : matrice con i valori v dei pixel dell'immagine",
" * parametro mask : matrice di booleani da riempire ad opera della procedura",
" */",
"public void chromaKey( double u, double v, double radius, double[][] uData, double[][] vData,",
"                       boolean[][] mask ){",
"",
"  // Itero su tutti i pixel dell'immagine",
"  for(int x=0; x<320; x++){",
"    for(int y=0; y<240; y++){",
"",
"      // Calcolo la distanza fra il pixel e i valori di u e v desiderati",
"      double du = uData[x][y]-u;",
"      double dv = vData[x][y]-v;",
"",
"      // Ne faccio la somma dei quadrati",
"      double d2 = du*du+dv*dv;",
"",
"      // E calcolo il quadrato del raggio",
"      double r2 = radius*radius;",
"",
"      // Se la somma dei quadrati è inferiore al quadrato del raggio il pixel è valido",
"      mask[x][y] = d2<r2;",
"    }",
"  }",
"}",
""

};

public static final String[] houghTransformStub = new String[] {

"/**",
" * La procedura houghTransform deve riempire una accumulatore che viene passato già dimensionato sommando in esso",
" * i contributi di ciascun pixel dell'immagine attivo secondo una maschera.",
" * Inoltre devono essere calcolati i parametri alpha ed r e resituiti rispettivanete nell'array params",
" *",
" * parametro a_step : lo step da dare agli angoli",
" * parametro r_step : lo step da dare ad r",
" * parametro max_r : la massima distanza prevista fra retta ed origine",
" * parametro yData : matrice con i valori di luminosità dei pixel dell'immagine",
" * parametro mask : matrice con i valori di maschera per la barra da rilevare",
" * parametro accumulator : accumulatore dove sommare i valori dell'Hough Transform",
" * parametro params : array dove inserire rispettivamente alpha ed r",
" */",
"public void houghTransform( double a_step, double r_step, double max_r, double[][] yData, boolean[][] mask,",
"                            double[][] accumulator, double[] params ){",
"       // Inserire testo qui",
"}",
""

};

public static final String[] houghTransformReference = new String[] {

"/**",
" * La procedura houghTransform deve riempire una accumulatore che viene passato già dimensionato sommando in esso",
" * i contributi di ciascun pixel dell'immagine attivo secondo una maschera.",
" * Inoltre devono essere calcolati i parametri alpha ed r e resituiti rispettivanete nell'array params",
" *",
" * parametro a_step : lo step da dare agli angoli",
" * parametro r_step : lo step da dare ad r",
" * parametro max_r : la massima distanza prevista fra retta ed origine",
" * parametro yData : matrice con i valori di luminosità dei pixel dell'immagine",
" * parametro mask : matrice con i valori di maschera per la barra da rilevare",
" * parametro accumulator : accumulatore dove sommare i valori dell'Hough Transform",
" * parametro params : array dove inserire rispettivamente a ed r",
" */",
"public void houghTransform( double a_step, double r_step, double max_r, double[][] yData, boolean[][] mask,",
"                            double[][] accumulator, double[] params ){",
"",
"   // Variabili per immagazzinare i massimi trovati",
"   double current_a   = 0;",
"   double current_r   = 0;",
"   double current_max = 0;",
"",
"   // Esamino tutti i pixel dell'immagine",
"   for(int x=0; x<320; x++){",
"      for(int y=0; y<240; y++){",
"",
"         //Se un pixel è stato selezionato dalla maschera può far parte della barra",
"         if(mask[x][y]){",
"",
"            // Creo la sua curva trasformata iterando per ogni angolo",
"            for(double a=0.0; a<Math.PI; a+=a_step){",
"",
"               // Calcolo il parametro r per tale angolo",
"               double r = x * Math.cos(a) + y * Math.sin(a);",
"",
"               // Se tale parametro è compreso nei bound attesi...",
"               if((r>-max_r)&&(r<max_r)){",
"",
"                  // Calcolo la cella nell'accumulatore",
"                  int r_pos = (int)Math.round((r+max_r)/r_step);",
"                  int a_pos = (int)Math.round(a/a_step);",
"",
"                  // E vi aggiungo il valore della luminanza",
"                  accumulator[a_pos][r_pos] += yData[x][y];",
"",
"                  // Controllo se il valore ottenuto è superiore al massimo attuale",
"                  if(accumulator[a_pos][r_pos] > current_max){",
"                     current_max = accumulator[a_pos][r_pos];",
"                     current_a = a;",
"                     current_r = r;",
"                  }",
"",
"               }",
"            }",
"         }",
"      }",
"   }",
"",
"   // Restituisco i parametri trovati attraverso l'array params",
"   params[0] = current_a;",
"   params[1] = current_r;",
"",
"}",
""

};

public static final String[] buttonsDetectionStub = new String[] {

"/**",
" * La procedura buttonDetection in base alle maschere di presenza di barra e bottoni deve restituire lo stato",
" * di entrambi i pulsanti.",
" *",
" * parametro barMask : maschera della barra",
" * parametro buttonsMask : maschera dei bottoni",
" * parametro button : array dove inserire lo stato booleano dei due bottoni",
" */",
"public void buttonsDetection( boolean[] barMask, boolean[] buttonsMask,",
"                              boolean[] buttons ){",
"     // Inserire testo qui",
"}",
""

};

public static final String[] buttonsDetectionReference = new String[] {

"/**",
" * La procedura buttonDetection in base alle maschere di presenza di barra e bottoni deve restituire lo stato",
" * di entrambi i pulsanti.",
" *",
" * parametro barMask : maschera della barra",
" * parametro buttonsMask : maschera dei bottoni",
" * parametro button : array dove inserire lo stato booleano dei due bottoni",
" */",
"public void buttonsDetection( boolean[] barMask, boolean[] buttonsMask,",
"                              boolean[] buttons ){",
"",
"  // Prima di tutto calcolo il baricentro dell'area viola",
"  double barBarycenter = 0;",
"  int factors = 0;",
"  for(int x=0; x<320; x++){",
"    if(barMask[x]){",
"      barBarycenter += x;",
"      factors++;",
"    }",
"  }",
"  barBarycenter /= factors;",
"",
"  // Ora controllo se ho elementi verdi a destra o sinistra del baricentro",
"  buttons[0] = false;",
"  buttons[1] = false;",
"  if(barBarycenter != 0){",
"    for(int x=0; x<320; x++){",
"      if(buttonsMask[x]){",
"        if(x<barBarycenter)",
"          buttons[0] = true;",
"        else",
"          buttons[1] = true;",
"      }",
"    }",
"  }",
"}",
""

};

}
